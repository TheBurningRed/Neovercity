# Аналіз алгоритмів видачі решти

У цьому завданні було реалізовано два підходи до розв'язання задачі про монети: жадібний алгоритм та алгоритм динамічного програмування.

## Порівняння характеристик

| Характеристика | Жадібний алгоритм (`find_coins_greedy`) | Динамічне програмування (`find_min_coins`) |
| :--- | :--- | :--- |
| **Складність часу** | O(n), де n — кількість номіналів монет | O(m * n), де m — сума, n — кількість номіналів |
| **Складність пам'яті** | O(1) додаткової пам'яті | O(m) для зберігання таблиці сум |
| **Оптимальність** | Не завжди гарантує мінімальну кількість монет (залежить від системи номіналів) | Завжди знаходить глобально оптимальний результат (мінімум монет) |
| **Швидкість при великих сумах** | Працює миттєво незалежно від суми | Сповільнюється лінійно відносно зростання суми |

## Висновки

1. **Ефективність при великих сумах:**
   Жадібний алгоритм є значно швидшим, оскільки він просто виконує кілька операцій ділення. Для касової системи, де суми можуть бути великими, а набір монет є "стандартним" (як-от 1, 2, 5, 10, 25, 50), жадібний алгоритм працює ідеально.

2. **Точність та оптимальність:**
   Динамічне програмування є незамінним, якщо набір номіналів монет "неправильний" (наприклад, 1, 3, 4). Для суми 6 жадібний алгоритм видасть `4 + 1 + 1` (3 монети), тоді як динамічний знайде оптимальний варіант `3 + 3` (2 монети).

3. **Практичне застосування:**
   У реальних касових системах більшість валют світу розроблені так, щоб жадібний алгоритм завжди давав оптимальний результат. Тому у звичайних умовах використання **жадібного алгоритму** є кращим вибором через його продуктивність. Однак, якщо потрібно гарантувати мінімальну кількість монет для будь-якого набору номіналів, слід використовувати **динамічне програмування**, попри більші витрати пам'яті та часу.
